import csv from 'csv-parser';
import { Readable } from 'stream';
import { sendErrorResponse } from "../utils/sendError.js";
import { sendSuccessResponse } from "../utils/sendSuccess.js";
import { query } from '../config/database.js';
import { SCRIPT } from '../constants/script.js';

export const parseCsvFile = (file) => {
    return new Promise((resolve, reject) => {
      const results = [];
      const stream = Readable.from(file.buffer);
  
      stream
        .pipe(csv({
          mapHeaders: ({ header }) => header.trim()
        }))
        .on("data", (row) => {
          results.push(row);
        })
        .on("error", (err) => {
          reject(sendErrorResponse(500, err.message));
        })
        .on("end", () => {
          resolve(sendSuccessResponse(200, 'CSV file parsed successfully', results));
        });
    });
};

export const _get_unique_vulnerability = (vulnerabilities) => {
  const unique_vulnerability = new Set();
  const unique_vulnerability_list = [];

  vulnerabilities.forEach(vulnerability => {
    const id = vulnerability.cve_id || vulnerability.kb_id;
    if (!id) return;
    if (unique_vulnerability.has(id)) {
      return;
    }
    unique_vulnerability.add(id);
    unique_vulnerability_list.push(vulnerability);
  });

  return unique_vulnerability_list;
};

export const _validate_lixux_vulnerability = async (vulnerabilities) => {
  const ips = [...new Set(vulnerabilities.map(v => v.ip_address))];

  const hosts_data = (await query(SCRIPT.GET_HOSTS_BY_IPS, [ips])).rows;

  if (hosts_data.length !== ips.length) {
    throw new Error("Some duplicate ips error");
  }

  const hostMap = new Map();
  hosts_data.forEach(host => {
    hostMap.set(host.ip, host);
  });

  const result = vulnerabilities.map(vulnerability => {
    const { ip_address, host_name, cve_id } = vulnerability;

    const host = hostMap.get(ip_address);

    if (!host || host.host_name !== host_name) {
      throw new Error("Invalid IP and host_name combination found");
    }

    return {
      ip_address,
      host_name,
      host_id: host.id,
      cve_id
    };
  });

  return result;
};
export const _bulk_add_linux_vulnerability = async (vulnerabilities) => {
  if (!vulnerabilities.length) return;
  const values = [];

  const placeholders = vulnerabilities.map((v, i) => {
    const base = i * 6;
    values.push(
      v.cve_id,
      v.severity,
      v.cvss_score,
      v.package_name,
      v.os_type,
      v.os_version
    );

    return `(
      $${base + 1},
      $${base + 2},
      $${base + 3},
      $${base + 4},
      $${base + 5},
      $${base + 6}
    )`;
  }).join(",");

  await query(
    SCRIPT.BULK_ADD_LINUX_VULNERABILITY(placeholders),
    values
  );
};

export const _bulk_linux_vulnerability_mapping = async (hostData) => {
  if (!hostData.length) return;

  const unique = new Map();

  hostData.forEach(item => {
    const key = `${item.cve_id}-${item.host_id}`;
    if (!unique.has(key)) {
      unique.set(key, [
        item.cve_id,
        item.host_id,
      ]);
    }
  });

  const valuesArray = Array.from(unique.values());
  const flatValues = valuesArray.flat();

  const placeholders = valuesArray
    .map((_, i) => {
      const base = i * 2;
      return `($${base + 1}, $${base + 2})`;
    })
    .join(",");

  await query(
    SCRIPT.BULK_ADD_LINUX_VULNERABILITY_MAPPING(placeholders),
    flatValues
  );
};
