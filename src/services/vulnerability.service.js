import { sendSuccessResponse } from "../utils/sendSuccess.js";
import { validate_linux_vulnerability } from "../validations/vulnerability.validation.js";
import { validate_windows_vulnerability } from "../validations/vulnerability.validation.js";
import { formatZodErrorsArray } from "../utils/formatZodError.js";
import { sendErrorResponse } from "../utils/sendError.js";
import { query } from '../config/database.js';
import { SCRIPT } from '../constants/script.js';

const vulnerabilityService = {};

const _bulk_add_vulnerability = async (unique_vulnerability) => {
  const values = [];
  const placeholders = unique_vulnerability.map((v, i) => {
    const baseIndex = i * 6;

    values.push(
      v.cve_id,
      v.severity,
      v.cvss_score,
      v.package_name,
      v.os_type,
      v.os_version
    );

    return `(
  $${baseIndex + 1},
  $${baseIndex + 2},
  $${baseIndex + 3},
  $${baseIndex + 4},
  $${baseIndex + 5},
  $${baseIndex + 6}
)`;
  }).join(',');

  await query(
    SCRIPT.BULK_ADD_LINUX_VULNERABILITY(placeholders),
    values
  );
}

const _get_unique_vulnerability = (vulnerabilities) => {
  const unique_vulnerability = new Set();
  const unique_vulnerability_list = [];

  vulnerabilities.forEach(vulnerability => {
    const id = vulnerability.cve_id || vulnerability.kb_id;
    if (!id) return;
    if (unique_vulnerability.has(id)) {
      return;
    }
    unique_vulnerability.add(id);
    unique_vulnerability_list.push(vulnerability);
  });

  return unique_vulnerability_list;
};

vulnerabilityService.addLinuxVulnerability = async (data) => {
  const validatedData = validate_linux_vulnerability.safeParse(data);
  if (!validatedData.success) {
    return sendErrorResponse(400, formatZodErrorsArray(validatedData.error));
  }
  const vulnerabilities = validatedData.data;

  const unique_vulnerability_list = _get_unique_vulnerability(vulnerabilities);

  try {
    await query(SCRIPT.BEGIN_TRANSACTION);

    if (unique_vulnerability_list.length === 0) return;

    
    const ips = [...new Set(vulnerabilities.map(v => v.ip_address))];
    const hosts = await query(SCRIPT.GET_HOSTS_BY_IPS, [ips]);
    
    
    // bulk add vulnerabilities
    // await _bulk_add_vulnerability(unique_vulnerability_list)

    // mapping
    // await query(SCRIPT.BULK_ADD_LINUX_VULNERABILITY_MAPPING(placeholders), flatValues);
    
    await query(SCRIPT.COMMIT);
    return sendSuccessResponse(200, 'Linux vulnerability added successfully', unique_vulnerability_list);
  } catch (error) {
    await query(SCRIPT.ROLLBACK);
    return sendErrorResponse(499, "EROOR")
  }
}

vulnerabilityService.addWindowsVulnerability = async (data) => {
  const validatedData = validate_windows_vulnerability.safeParse(data);
  if (!validatedData.success) {
    return sendErrorResponse(400, formatZodErrorsArray(validatedData.error));
  }
  const vulnerabilities = validatedData.data;

  const unique_vulnerability_list = _get_unique_vulnerability(vulnerabilities);

  try {
    await query(SCRIPT.BEGIN_TRANSACTION);

    if (unique_vulnerability_list.length === 0) return;

    
    const ips = [...new Set(vulnerabilities.map(v => v.ip_address))];
    const hosts = await query(SCRIPT.GET_HOSTS_BY_IPS, [ips]);

        // TODO:
    // bulk insert windows_vulnerability
    // bulk insert windows_vulnerability_mapping
    
    await query(SCRIPT.COMMIT);
    return sendSuccessResponse(200, 'Windows vulnerability added successfully', unique_vulnerability_list);
  } catch (error) {
    await query(SCRIPT.ROLLBACK);
    return sendErrorResponse(499, "EROOR")
  }
}

export default vulnerabilityService;