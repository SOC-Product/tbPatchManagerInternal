import { sendSuccessResponse } from "../utils/sendSuccess.js";
import { validate_linux_vulnerability } from "../validations/vulnerability.validation.js";
import { formatZodErrorsArray } from "../utils/formatZodError.js";
import { sendErrorResponse } from "../utils/sendError.js";
import { query } from '../config/database.js';
import { SCRIPT } from '../constants/script.js';

const vulnerabilityService = {};

const _bulk_add_linux_vulnerability = async (vulnerabilities) => {
  if (!vulnerabilities.length) return;

  const values = [];

  const placeholders = vulnerabilities.map((v, i) => {
    const base = i * 6;

    values.push(
      v.cve_id,
      v.severity,
      v.cvss_score,
      v.package_name,
      v.os_type,
      v.os_version
    );

    return `(
      $${base + 1},
      $${base + 2},
      $${base + 3},
      $${base + 4},
      $${base + 5},
      $${base + 6}
    )`;
  }).join(",");

  await query(
    SCRIPT.BULK_ADD_LINUX_VULNERABILITY(placeholders),
    values
  );
};


const _get_unique_vulnerability = (vulnerabilities) => {
  const unique_vulnerability = new Set();
  const unique_vulnerability_list = [];

  vulnerabilities.forEach(vulnerability => {
    if (unique_vulnerability.has(vulnerability.cve_id)) {
      return;
    }
    unique_vulnerability.add(vulnerability.cve_id);
    unique_vulnerability_list.push(vulnerability);
  })
  return unique_vulnerability_list;
}

const _validate_vulnerability = async (vulnerabilities) => {
  const ips = [...new Set(vulnerabilities.map(v => v.ip_address))];

  const hosts_data = (await query(SCRIPT.GET_HOSTS_BY_IPS, [ips])).rows;

  if (hosts_data.length !== ips.length) {
    throw new Error("Some duplicate ips error");
  }

  const hostMap = new Map();
  hosts_data.forEach(host => {
    hostMap.set(host.ip, host);
  });

  const result = vulnerabilities.map(vulnerability => {
    const { ip_address, host_name, cve_id } = vulnerability;

    const host = hostMap.get(ip_address);

    if (!host || host.host_name !== host_name) {
      throw new Error("Invalid IP and host_name combination found");
    }

    return {
      ip_address,
      host_name,
      host_id: host.id,
      cve_id
    };
  });

  return result;
};


const _bulk_linux_vulnerability_mapping = async (hostData) => {
  if (!hostData.length) return;

  const unique = new Map();

  hostData.forEach(item => {
    const key = `${item.cve_id}-${item.host_id}`;
    if (!unique.has(key)) {
      unique.set(key, [
        item.cve_id,
        item.host_id,
      ]);
    }
  });

  const valuesArray = Array.from(unique.values());
  const flatValues = valuesArray.flat();

  const placeholders = valuesArray
    .map((_, i) => {
      const base = i * 2;
      return `($${base + 1}, $${base + 2})`;
    })
    .join(",");

  await query(
    SCRIPT.BULK_ADD_LINUX_VULNERABILITY_MAPPING(placeholders),
    flatValues
  );
};


vulnerabilityService.addLinuxVulnerability = async (data) => {
  const validatedData = validate_linux_vulnerability.safeParse(data);
  if (!validatedData.success) {
    return sendErrorResponse(400, formatZodErrorsArray(validatedData.error));
  }
  const vulnerabilities = validatedData.data;

  const unique_vulnerability_list = _get_unique_vulnerability(vulnerabilities);

  try {
    await query(SCRIPT.BEGIN_TRANSACTION);

    const host_data = await _validate_vulnerability(vulnerabilities);

    await _bulk_add_linux_vulnerability(unique_vulnerability_list)

    await _bulk_linux_vulnerability_mapping(host_data);

    await query(SCRIPT.COMMIT);
    return sendSuccessResponse(200, 'Linux vulnerability added successfully');
  } catch (error) {
    await query(SCRIPT.ROLLBACK);
    return sendErrorResponse(499, error)
  }
}

export default vulnerabilityService;