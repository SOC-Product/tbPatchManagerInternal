import { sendSuccessPagination, sendSuccessResponse } from "../utils/sendSuccess.js";
import { validate_linux_vulnerability } from "../validations/vulnerability.validation.js";
import { 
  _bulk_add_linux_vulnerability,
  _bulk_linux_vulnerability_mapping,
  _get_unique_vulnerability,
  _validate_lixux_vulnerability 
} from "../helpers/vulnerability.helper.js";
import { formatZodErrorsArray } from "../utils/formatZodError.js";
import { sendErrorResponse } from "../utils/sendError.js";
import { query } from '../config/database.js';
import { SCRIPT } from '../constants/script.js';

const vulnerabilityService = {};


vulnerabilityService.addLinuxVulnerability = async (data) => {
  const validatedData = validate_linux_vulnerability.safeParse(data);
  if (!validatedData.success) {
    return sendErrorResponse(400, formatZodErrorsArray(validatedData.error));
  }
  const vulnerabilities = validatedData.data;

  const unique_vulnerability_list = _get_unique_vulnerability(vulnerabilities);

  try {
    await query(SCRIPT.BEGIN_TRANSACTION);

    const host_data = await _validate_lixux_vulnerability(vulnerabilities);

    await _bulk_add_linux_vulnerability(unique_vulnerability_list)

    await _bulk_linux_vulnerability_mapping(host_data);

    await query(SCRIPT.COMMIT);
    return sendSuccessResponse(200, 'Linux vulnerability added successfully');
  } catch (error) {
    await query(SCRIPT.ROLLBACK);
    return sendErrorResponse(499, error.message || 'Internal Server Error')
  }
}

vulnerabilityService.getLinux = async (page, limit, search) => {
  const count = await query(SCRIPT.GET_LINUX_VULNERABILITY_COUNT_BY_SEARCH, [search]);
  const linux = await query(SCRIPT.GET_LINUX_VULNERABILITY_BY_SEARCH, [search, limit, page * limit]);
  return sendSuccessPagination(200, 'Linux vulnerability fetched successfully', linux.rows, limit, page, count.rows[0].count);
}

vulnerabilityService.deleteLinux = async (linux_ids) => {

    const ids = await query(SCRIPT.GET_LINUX_CVE_ID, [linux_ids]);
    if(ids.length != linux_ids.length){
      return sendErrorResponse(404, "Some cve ids are invalid or does not exist");
    }
    
    await query(SCRIPT.DELETE_LINUX, [linux_ids]);
    return sendSuccessResponse(200, 'Vulnerabilities with ids delete successfully', linux_ids);
}

vulnerabilityService.addWindowsVulnerability = async (data) => {
  const validatedData = validate_windows_vulnerability.safeParse(data);
  if (!validatedData.success) {
    return sendErrorResponse(400, formatZodErrorsArray(validatedData.error));
  }
  const vulnerabilities = validatedData.data;

  const unique_vulnerability_list = _get_unique_vulnerability(vulnerabilities);

  try {
    await query(SCRIPT.BEGIN_TRANSACTION);

    if (unique_vulnerability_list.length === 0) return;

    
    const ips = [...new Set(vulnerabilities.map(v => v.ip_address))];
    const hosts = await query(SCRIPT.GET_HOSTS_BY_IPS, [ips]);

        // TODO:
    // bulk insert windows_vulnerability
    // bulk insert windows_vulnerability_mapping
    
    await query(SCRIPT.COMMIT);
    return sendSuccessResponse(200, 'Windows vulnerability added successfully', unique_vulnerability_list);
  } catch (error) {
    await query(SCRIPT.ROLLBACK);
    return sendErrorResponse(499, "EROOR")
  }
}
export default vulnerabilityService;